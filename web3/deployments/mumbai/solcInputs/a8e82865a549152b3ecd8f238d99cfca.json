{
  "language": "Solidity",
  "sources": {
    "contracts/SportsChallenge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract SportsChallenges {\n    enum MatchStatus {\n        PENDING,\n        ACCEPTED,\n        STARTED,\n        ENDED\n    }\n\n    struct MatchChallenge {\n        address team1;\n        address team2;\n        MatchStatus matchStatus;\n        uint256 amount;\n        address locationProvider;\n    }\n\n    // Match state variables\n    MatchChallenge[] public matchChallenges; // Contiene el numero de desafios\n\n    // EVENTS //\n    // Evento que salta cuando el LocationProvider define el final\n    event ChallengeResult(\n        uint256 indexed MatchChallengeId,\n        uint8 team1Result,\n        uint8 team2Result\n    );\n\n    function createChallenge(address _team2, address _locationProvider)\n        public\n        payable\n    {\n        matchChallenges.push(\n            MatchChallenge(\n                msg.sender,\n                _team2,\n                MatchStatus.PENDING,\n                msg.value,\n                _locationProvider\n            )\n        );\n    }\n\n    // Acepta el desafio\n    function acceptChallenge(uint256 _challengeId) public payable {\n        require(\n            msg.sender == matchChallenges[_challengeId].team2,\n            \"You're not the challenged team!\"\n        );\n        require(\n            msg.value >= matchChallenges[_challengeId].amount,\n            \"Haven't sent enough ETH!\"\n        );\n        matchChallenges[_challengeId].matchStatus = MatchStatus.ACCEPTED;\n    }\n\n    function updateLocationProvider(\n        uint256 _challengeId,\n        address _newLocationProvider\n    ) public {\n        require(\n            msg.sender == matchChallenges[_challengeId].team1 ||\n                msg.sender == matchChallenges[_challengeId].team2,\n            \"You're not any of the teams!\"\n        );\n        require(\n            matchChallenges[_challengeId].matchStatus >= MatchStatus.STARTED,\n            \"Challenge has already been started!\"\n        );\n\n        matchChallenges[_challengeId].locationProvider = _newLocationProvider;\n    }\n\n    function deleteChallenge(uint256 _challengeId) public {\n        // Check\n        require(\n            matchChallenges[_challengeId].matchStatus < MatchStatus.STARTED,\n            \"Challenge has already been started or finished!\"\n        );\n        require(\n            msg.sender == matchChallenges[_challengeId].team1 ||\n                msg.sender == matchChallenges[_challengeId].team2 ||\n                msg.sender == matchChallenges[_challengeId].locationProvider,\n            \"You're not any of the teams nor the location provider!\"\n        );\n\n        // Effect\n        matchChallenges[_challengeId].matchStatus = MatchStatus.ENDED;\n        // Interact\n        (bool success, ) = payable(matchChallenges[_challengeId].team1).call{\n            value: matchChallenges[_challengeId].amount\n        }(\"\");\n        require(success == true, \"ETH didn't send to team 1.\");\n        if (matchChallenges[_challengeId].matchStatus == MatchStatus.ACCEPTED) {\n            (bool success2, ) = payable(matchChallenges[_challengeId].team2)\n                .call{value: matchChallenges[_challengeId].amount}(\"\");\n            require(success2 == true, \"ETH didn't send to team 2.\");\n        }\n    }\n\n    function startChallenge(uint256 _challengeId) public {\n        // Check\n        require(\n            matchChallenges[_challengeId].matchStatus == MatchStatus.ACCEPTED,\n            \"Team2 hasn't accepted the challenge or it has already started!\"\n        );\n        require(\n            matchChallenges[_challengeId].locationProvider == msg.sender,\n            \"You're not the location provider!\"\n        );\n        require(\n            matchChallenges[_challengeId].team2 != address(0),\n            \"Lacking a team or match canceled\"\n        );\n\n        // Effect\n        matchChallenges[_challengeId].matchStatus = MatchStatus.ACCEPTED;\n    }\n\n    function completeChallenge(\n        uint256 _challengeId,\n        uint8 _team1Result,\n        uint8 _team2Result\n    ) public {\n        // Check\n        require(\n            matchChallenges[_challengeId].matchStatus == MatchStatus.STARTED,\n            \"Challenge hasn't started!\"\n        );\n        require(\n            msg.sender == matchChallenges[_challengeId].locationProvider,\n            \"You must be the location provider to say who won\"\n        );\n        // Effect\n        matchChallenges[_challengeId].matchStatus = MatchStatus.ENDED;\n        emit ChallengeResult(_challengeId, _team1Result, _team2Result);\n        // Interact\n        uint256 prizeMinusLocationFee = (matchChallenges[_challengeId].amount *\n            2) - 0.002 ether;\n        (bool successL, ) = payable(\n            matchChallenges[_challengeId].locationProvider\n        ).call{value: 0.0015 ether}(\"\");\n        require(successL == true, \"ETH didn't send to location provider.\");\n\n        if (_team1Result > _team2Result) {\n            (bool success, ) = payable(matchChallenges[_challengeId].team1)\n                .call{value: prizeMinusLocationFee}(\"\");\n            require(success == true, \"ETH didn't send to team 1.\");\n        }\n        if (_team1Result < _team2Result) {\n            (bool success, ) = payable(matchChallenges[_challengeId].team2)\n                .call{value: prizeMinusLocationFee}(\"\");\n            require(success == true, \"ETH didn't send to team 2.\");\n        }\n        if (_team1Result == _team2Result) {\n            (bool success, ) = payable(matchChallenges[_challengeId].team1)\n                .call{value: (prizeMinusLocationFee / 2)}(\"\");\n            require(success == true, \"ETH didn't send to team 1.\");\n\n            (bool success2, ) = payable(matchChallenges[_challengeId].team2)\n                .call{value: (prizeMinusLocationFee / 2)}(\"\");\n            require(success2 == true, \"ETH didn't send to team 1.\");\n        }\n    }\n\n    function viewMatchChallenge(uint256 _id)\n        public\n        view\n        returns (address[3] memory)\n    {\n        address team1 = matchChallenges[_id].team1;\n        address team2 = matchChallenges[_id].team2;\n        address locationProvider = matchChallenges[_id].locationProvider;\n        address[3] memory answer = [team1, team2, locationProvider];\n        return answer;\n    }\n\n    function viewMatchStatus(uint256 _id) public view returns (MatchStatus) {\n        return matchChallenges[_id].matchStatus;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}